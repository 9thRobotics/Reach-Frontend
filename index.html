<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Buy Reach (9D-RC) â€” Mainnet</title>

  <style>
    :root{--bg:#071126;--card:#0b1220;--muted:#9fb0c2;--accent:#46abab}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:#e6eef6;padding:28px;display:flex;justify-content:center}
    .card{width:100%;max-width:820px;background:var(--card);padding:20px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.6)}
    h1{margin:0 0 6px;font-size:20px}
    label{display:block;margin-top:12px;color:var(--muted);font-size:13px}
    input,select,button{width:100%;padding:10px;border-radius:8px;border:1px solid #203843;background:#06111a;color:#e6eef6;font-size:15px}
    .row{display:flex;gap:10px}
    .row > *{flex:1}
    button.primary{background:var(--accent);border:none;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    pre{white-space:pre-wrap;word-break:break-word;color:#cfeee0;background:transparent;padding:0;margin:0}
    a.small{color:#7ee787}
    #status{margin-top:10px;font-weight:600}
  </style>

  <!-- Ethers.js v5 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <!-- Web3Modal HTML v2 (UMD) -->
  <script src="https://unpkg.com/@web3modal/html@2.5.0/dist/index.umd.min.js"></script>

  <!-- WalletConnect Web3Modal v2 (UMD) -->
  <script src="https://unpkg.com/@walletconnect/web3modal@2.7.0/dist/index.global.min.js"></script>
</head>
<body>
  <div class="card">
    <h1>Buy Reach (9D-RC)</h1>
    <div class="muted">Token contract: <a class="small" href="https://etherscan.io/token/0x41A61CdCf40a074546423Bae987B81733F3FBAc5" target="_blank" rel="noreferrer">0x41A61CdC...FBAc5</a></div>
    <div class="muted">Receiver wallet: <span class="small">0x0557afA4318989702376D50B45547F953B7f9B21</span></div>

    <label>Wallet</label>
    <div class="row">
      <input id="walletAddress" readonly placeholder="Not connected" />
      <button id="connectBtn" class="primary">Connect Wallet</button>
    </div>

    <label>Tokens to buy (whole tokens)</label>
    <input id="tokenQty" type="number" min="1" step="1" value="1" />

    <label>ETH required (calculated from on-chain price)</label>
    <input id="ethNeeded" readonly />

    <div class="row" style="margin-top:12px">
      <button id="calcBtn">Calculate ETH Needed</button>
      <button id="buyBtn" class="primary">Buy Tokens</button>
    </div>

    <div id="status" class="muted">Ready.</div>
    <div id="txInfo" style="margin-top:10px"></div>
  </div>

  <script>
  (async () => {
    // ---------- CONFIG ----------
    const TOKEN_CONTRACT = "0x41A61CdCf40a074546423Bae987B81733F3FBAc5";
    const RECEIVER_WALLET = "0x0557afA4318989702376D50B45547F953B7f9B21";
    const CHAIN_CAIP = "eip155:1"; // WalletConnect CAIP for Ethereum mainnet
    const CHAIN_ID = 1;
    const ETHERSCAN_TX = "https://etherscan.io/tx/";

    // Minimal ABI
    const ABI = [
      "function buyTokens() payable",
      "function getLatestPrice() view returns (uint256)",
      "function floorPrice() view returns (uint256)"
    ];

    // Public WalletConnect v2 projectId (you can replace with yours)
    const WC_PROJECT_ID = "c9a8238f1e4b213249f3dfd76bd84f89";

    // UI refs
    const connectBtn = document.getElementById("connectBtn");
    const walletAddressInput = document.getElementById("walletAddress");
    const tokenQtyInput = document.getElementById("tokenQty");
    const ethNeededInput = document.getElementById("ethNeeded");
    const calcBtn = document.getElementById("calcBtn");
    const buyBtn = document.getElementById("buyBtn");
    const statusEl = document.getElementById("status");
    const txInfo = document.getElementById("txInfo");

    // runtime
    let web3Modal;      // Web3Modal HTML instance
    let web3Provider;   // provider returned by modal (EIP-1193)
    let provider;       // ethers provider
    let signer;
    let contract;

    function setStatus(msg, color = "#9fb0c2") {
      statusEl.style.color = color;
      statusEl.textContent = msg;
    }

    // --------- Init Web3Modal HTML (v2) with CAIP chain object ----------
    try {
      const modalOptions = {
        projectId: WC_PROJECT_ID,
        theme: "dark",
        accentColor: "46abab",
        chains: [
          {
            id: CHAIN_CAIP,
            name: "Ethereum Mainnet",
            rpcUrls: {
              default: { http: ["https://rpc.ankr.com/eth"] }
            },
            nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 }
          }
        ],
        metadata: {
          name: "9th Dimension â€” Reach Sale",
          description: "Buy Reach (9D-RC) tokens",
          url: window.location.origin,
          icons: []
        }
      };

      // Web3Modal HTML exposes Web3ModalHTML.Web3Modal
      web3Modal = new window.Web3ModalHTML.Web3Modal(modalOptions);
    } catch (e) {
      console.error("web3modal init error", e);
      setStatus("Failed to initialize wallet modal. Check console.", "#f1a1a1");
    }

    // ---------- Connect wallet (tries injected first; if it fails opens modal) ----------
    async function connectWallet() {
      setStatus("Connecting...");
      try {
        // Prefer injected provider (MetaMask / injected wallet)
        if (window.ethereum && window.ethereum.request) {
          // Try to switch to mainnet first (this won't throw on mobile providers)
          try {
            await window.ethereum.request({ method: "wallet_switchEthereumChain", params:[{ chainId: "0x1" }] });
          } catch (_) { /* ignore, wallet may not support switch */ }

          // request accounts
          await window.ethereum.request({ method: "eth_requestAccounts" });
          web3Provider = window.ethereum;
        } else {
          // No injected provider â€” open web3modal to choose (WalletConnect QR, etc.)
          web3Provider = await web3Modal.connect();
        }

        // Wrap with ethers provider
        provider = new ethers.providers.Web3Provider(web3Provider, "any");
        signer = provider.getSigner();
        const network = await provider.getNetwork();
        if (network.chainId !== CHAIN_ID) {
          setStatus("Switch your wallet to Ethereum Mainnet.", "#f1a1a1");
        }

        const addr = await signer.getAddress();
        walletAddressInput.value = addr;
        contract = new ethers.Contract(TOKEN_CONTRACT, ABI, signer);
        setStatus("Connected: " + addr, "#7ee787");

        // handle provider disconnects or account changes
        if (web3Provider && web3Provider.on) {
          web3Provider.on("accountsChanged", () => { disconnectWallet(); });
          web3Provider.on("chainChanged", () => { disconnectWallet(); });
          web3Provider.on("disconnect", () => { disconnectWallet(); });
        }
      } catch (err) {
        console.error("connectWallet err", err);
        setStatus("Connection failed or cancelled.", "#f1a1a1");
        // If injected provider crashed (Trust extension bug), automatically open Web3Modal as fallback
        if (err && err.message && err.message.toLowerCase().includes("could not establish connection")) {
          try {
            setStatus("Injected wallet failed â€” falling back to WalletConnect modal...", "#f1a1a1");
            web3Provider = await web3Modal.connect();
            provider = new ethers.providers.Web3Provider(web3Provider, "any");
            signer = provider.getSigner();
            const addr = await signer.getAddress();
            walletAddressInput.value = addr;
            contract = new ethers.Contract(TOKEN_CONTRACT, ABI, signer);
            setStatus("Connected via WalletConnect: " + addr, "#7ee787");
          } catch (e2) {
            console.error("fallback connect failed", e2);
            setStatus("Fallback connect failed. See console.", "#f1a1a1");
          }
        }
      }
    }

    connectBtn.addEventListener("click", connectWallet);

    async function disconnectWallet() {
      try {
        if (web3Provider && web3Provider.disconnect) {
          try { await web3Provider.disconnect(); } catch(e){/*ignore*/ }
        }
      } catch(e){}
      try { web3Modal && web3Modal.clearCachedProvider && web3Modal.clearCachedProvider(); } catch(e){}
      web3Provider = provider = signer = contract = null;
      walletAddressInput.value = "";
      ethNeededInput.value = "";
      txInfo.innerHTML = "";
      setStatus("Disconnected");
    }

    // ---------- Calculate ETH needed ----------
    // tokensToBuy = (msg.value * 1e18) / currentPrice
    // => msg.value = tokens * currentPrice / 1e18
    async function calculateEthNeeded() {
      if (!contract) { setStatus("Connect wallet first to read price.", "#f1a1a1"); return; }
      try {
        setStatus("Reading on-chain price...");
        const currentPrice = await contract.getLatestPrice(); // BigNumber
        const tokens = Math.floor(Number(tokenQtyInput.value) || 0);
        if (tokens < 1) { setStatus("Enter token amount (>=1).", "#f1a1a1"); return; }
        const tokensBN = ethers.BigNumber.from(String(tokens));
        const WEI = ethers.BigNumber.from("1000000000000000000"); // 1e18
        const ethNeededWei = tokensBN.mul(currentPrice).div(WEI);
        ethNeededInput.value = ethers.utils.formatEther(ethNeededWei);
        setStatus("ETH needed calculated.");
        return ethNeededWei;
      } catch (err) {
        console.error("calculateEthNeeded err", err);
        setStatus("Failed to read price. See console.", "#f1a1a1");
      }
    }

    calcBtn.addEventListener("click", calculateEthNeeded);

    // ---------- Buy Tokens ----------
    buyBtn.addEventListener("click", async () => {
      if (!contract) { setStatus("Connect wallet first.", "#f1a1a1"); return; }
      const tokensCount = Math.floor(Number(tokenQtyInput.value) || 0);
      if (tokensCount < 1) return alert("Enter token quantity (>=1).");

      try {
        setStatus("Calculating ETH needed...");
        const currentPrice = await contract.getLatestPrice();
        const tokensBN = ethers.BigNumber.from(String(tokensCount));
        const WEI = ethers.BigNumber.from("1000000000000000000");
        const ethNeededWei = tokensBN.mul(currentPrice).div(WEI);

        setStatus("Sending transaction â€” confirm in wallet...");
        const tx = await contract.buyTokens({ value: ethNeededWei });

        txInfo.innerHTML = `<div class="muted">Tx submitted: <pre>${tx.hash}</pre></div>`;
        setStatus("Waiting for confirmation...");
        await tx.wait();

        setStatus("Purchase confirmed! ðŸŽ‰", "#7ee787");
        txInfo.innerHTML += `<div>View on Etherscan: <a class="small" href="${ETHERSCAN_TX}${tx.hash}" target="_blank" rel="noreferrer">${tx.hash}</a></div>`;
      } catch (err) {
        console.error("buy err", err);
        const msg = err && err.message ? err.message : String(err);
        setStatus("Transaction failed: " + msg, "#f1a1a1");

        // If Trust Wallet extension bug appears, suggest WalletConnect QR
        if (msg && msg.toLowerCase().includes("could not establish connection")) {
          if (confirm("Your extension wallet failed to complete the request. Use WalletConnect (mobile) instead?")) {
            try {
              web3Provider = await web3Modal.connect();
              provider = new ethers.providers.Web3Provider(web3Provider, "any");
              signer = provider.getSigner();
              contract = new ethers.Contract(TOKEN_CONTRACT, ABI, signer);
              setStatus("Connected via WalletConnect. Please re-submit purchase.", "#7ee787");
            } catch (e) {
              console.error("walletconnect fallback error", e);
              setStatus("Unable to open WalletConnect. See console.", "#f1a1a1");
            }
          }
        }
      }
    });

    // final
    setStatus("Ready. Connect a wallet to begin.");
  })();
  </script>
</body>
</html>
